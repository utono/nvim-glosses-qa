Provide path to gloss-play_<play-name>.sh to create line-by-line glosses.

**Arguments: $ARGUMENTS**

The argument can be either:
- A play name (e.g., `henry-v`) - will look for script in scripts directory
- A full path to the script (e.g., `~/utono/nvim-glosses-qa/scripts/gloss-play_henry-v.sh`)

## Usage

```
# By play name
/gloss-play henry-v
/gloss-play hamlet --dry-run

# By full path
/gloss-play ~/utono/nvim-glosses-qa/scripts/gloss-play_henry-v.sh
/gloss-play ~/utono/nvim-glosses-qa/scripts/gloss-play_hamlet.sh --resume
```

## What This Does

1. Determines script path (from name or uses provided path directly)
2. Checks cache status (if no flags provided)
3. Auto-adds `--resume` if cached scenes exist (skips redundant work)
4. Runs the script with flags
5. Monitors output for errors and `[CLAUDE_ACTION_REQUIRED]` markers
6. Reports results and suggests next steps if issues occur

## Available Flags

Pass these after the play name:

| Flag | Purpose |
|------|---------|
| `--dry-run` | Preview what will be processed without API calls |
| `--status` | Show cache status (what's done vs pending) |
| `--validate` | Verify all scenes exist before processing |
| `--resume` | Skip fully-cached scenes (use after interruption) |

## Steps to Execute

### Step 1: Parse arguments

Extract script identifier (first argument) and any flags (remaining arguments).

Determine if first argument is a path or a play name:
- If it contains `/` or ends with `.sh` → treat as full path
- Otherwise → treat as play name, construct path

Examples:
- `/gloss-play henry-v` → script="gloss-play_henry-v.sh", flags=""
- `/gloss-play hamlet --dry-run` → script="gloss-play_hamlet.sh", flags="--dry-run"
- `/gloss-play ~/utono/.../gloss-play_henry-v.sh` → use path directly
- `/gloss-play ~/utono/.../gloss-play_hamlet.sh --resume` → use path, flags="--resume"

### Step 2: Verify script exists

If play name provided, check `~/utono/nvim-glosses-qa/scripts/gloss-play_<play-name>.sh`.
If full path provided, verify that path exists.

If not found, list available scripts:
```bash
ls ~/utono/nvim-glosses-qa/scripts/gloss-play_*.sh
```

### Step 3: Auto-detect cached scenes

**Skip this step if user provided any flags** (--dry-run, --status, --validate,
--resume). Only auto-detect when running without flags.

Run the script with `--status` to check cache state:
```bash
<script-path> --status
```

Parse the output for:
- "Cached: N scenes"
- "Pending: M scenes"

**Decision logic:**
- If Cached > 0 AND Pending > 0: Automatically add `--resume` flag
- If Cached > 0 AND Pending = 0: Report "All scenes already cached" and stop
- If Cached = 0: Run normally without --resume

When auto-adding `--resume`, inform the user:
```
Found N cached scenes, M pending. Automatically using --resume to skip cached.
```

### Step 4: Run the script

Execute the script with flags (including auto-added --resume if applicable):
```bash
<script-path> <flags>
```

### Step 5: Monitor and respond

Watch the output for:
- `[FAILED]` markers indicating scene failures
- `[CLAUDE_ACTION_REQUIRED]` indicating intervention needed
- `[SKIPPED]` markers (in resume mode) showing cached scenes
- Final summary with success/failure counts

### Step 6: Report results

After completion, summarize:
- Total scenes processed
- Any failures and their causes
- Suggested next steps if errors occurred
- Location of output files

## Error Recovery

If the script fails or is interrupted:

1. **Check status**: `/gloss-play <name> --status`
2. **Resume**: `/gloss-play <name> --resume`
3. **Check logs**: `~/utono/nvim-glosses-qa/logs/scene_analyzer.log`

## Examples

```
# By play name
/gloss-play henry-v --validate
/gloss-play henry-v
/gloss-play hamlet --status
/gloss-play macbeth --resume

# By full path
/gloss-play ~/utono/nvim-glosses-qa/scripts/gloss-play_henry-v.sh
/gloss-play ~/utono/nvim-glosses-qa/scripts/gloss-play_hamlet.sh --dry-run
```

## Notes

- Scripts are generated by `/analyze-plays` command
- Output goes to `~/utono/literature/glosses/<play-name>/`
- Caching means reruns skip already-processed chunks
- Use `--resume` for efficient restart after interruption
