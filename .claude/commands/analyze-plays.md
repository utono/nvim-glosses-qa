Generate shell scripts to analyze Shakespeare plays line-by-line.

**Arguments: $ARGUMENTS**

Arguments should be one or more paths to play files. Wildcards are supported:
- Single file: `~/utono/literature/shakespeare-william/gutenberg/henry_v_gut.txt`
- Multiple files: `~/utono/literature/shakespeare-william/gutenberg/*.txt`
- Specific plays: `~/utono/.../hamlet_gut.txt ~/utono/.../macbeth_gut.txt`

## Usage

```
/analyze-plays ~/utono/literature/shakespeare-william/gutenberg/henry_v_gut.txt
/analyze-plays ~/utono/literature/shakespeare-william/gutenberg/*.txt
/analyze-plays ~/utono/.../hamlet_gut.txt ~/utono/.../othello_gut.txt
```

## What This Does

1. **Expands wildcards** to find all matching .txt files
2. **Reads each play file** to discover its complete structure
3. **Identifies all acts, scenes, prologues, and epilogues** per play
4. **Generates a shell script** for each play
5. **Reports summary** of all generated scripts

## Steps to Execute

### Step 1: Expand arguments and find files

Expand `~` to full path. Expand wildcards using glob patterns.
Filter to only existing `.txt` files. Report how many plays found.

Example:
```
Found 37 play files matching: ~/utono/literature/shakespeare-william/gutenberg/*.txt
```

### Step 2: For each play file, analyze structure

Search the play file for structural markers using these patterns:
- `^PROLOGUE\.\s*$` - Prologue markers
- `^ACT\s+([IVX]+|FIRST|SECOND|THIRD|FOURTH|FIFTH)\.\s*$` - Act markers
- `^SCENE\s+([IVX]+)\.` - Scene markers
- `^EPILOGUE\.\s*$` - Epilogue marker

Build a structure like:
```
{
  "has_opening_prologue": true/false,  # PROLOGUE before any ACT
  "acts": {
    1: {"has_prologue": false, "scenes": [1, 2]},
    2: {"has_prologue": true, "scenes": [1, 2, 3, 4]},
    ...
  },
  "has_epilogue": true/false
}
```

**Important**: Track whether prologues appear:
- Before any ACT marker = opening prologue (act=0, scene=0)
- After an ACT marker but before SCENE = act prologue (act=N, scene=0)

### Step 3: Extract play name

From filename: `henry_v_gut.txt` → `henry-v`

### Step 4: Generate shell script for each play

Create script at: `~/utono/nvim-glosses-qa/scripts/gloss-play_{play_name}.sh`

Script template:
```bash
#!/bin/bash
# gloss-play_{play_name}.sh - Analyze the entirety of {Play Name}
# Generated by /analyze-plays command
#
# Usage: ./gloss-play_{play_name}.sh [--status] [--dry-run] [--resume] [--validate]
#
# Options:
#   --status, -s    Show cache status for all scenes (what's done vs pending)
#   --dry-run, -n   Preview without API calls
#   --resume, -R    Skip scenes that are fully cached (resume interrupted run)
#   --validate, -V  Validate all scenes exist in play file before processing
#
# Structure discovered:
#   - Opening Prologue: {yes/no}
#   - Acts: {list}
#   - Epilogue: {yes/no}
#   - Total output files: {count}

PLAY="{full_path_to_play}"
ANALYZER=~/utono/nvim-glosses-qa/python/scene_analyzer.py
MERGE=42
LOG_FILE=~/utono/nvim-glosses-qa/logs/scene_analyzer.log
DRY_RUN=""
STATUS_ONLY=""
RESUME_MODE=""
VALIDATE_MODE=""

# Parse command line arguments
for arg in "$@"; do
    case $arg in
        --status|-s)
            STATUS_ONLY="--status"
            ;;
        --dry-run|-n)
            DRY_RUN="--dry-run"
            ;;
        --resume|-R)
            RESUME_MODE="1"
            ;;
        --validate|-V)
            VALIDATE_MODE="1"
            ;;
    esac
done

# Status mode: check cache status for all scenes
if [ -n "$STATUS_ONLY" ]; then
    echo "=== {Play Name} - Cache Status ==="
    echo ""
    CACHED=0
    PENDING=0

    # (Each scene check is generated here, collecting status)
    {status_checks}

    echo ""
    echo "=== Summary ==="
    echo "Cached: $CACHED scenes"
    echo "Pending: $PENDING scenes"
    if [ "$PENDING" -eq 0 ]; then
        echo "All scenes cached - nothing to process"
    else
        echo "Run without --status to process pending scenes"
    fi
    exit 0
fi

# Validate mode: check all scenes exist before processing
if [ -n "$VALIDATE_MODE" ]; then
    echo "=== {Play Name} - Validating Script ==="
    echo ""
    VALID=0
    INVALID=0

    # (Each scene validation is generated here)
    {validate_checks}

    echo ""
    echo "=== Validation Summary ==="
    echo "Found: $VALID scenes"
    echo "Missing: $INVALID scenes"
    if [ "$INVALID" -eq 0 ]; then
        echo "All scenes validated - script is correct"
        exit 0
    else
        echo ""
        echo "[CLAUDE_ACTION_REQUIRED]"
        echo "$INVALID scene(s) not found in play file."
        echo "Script may need regeneration with /analyze-plays"
        exit 1
    fi
fi

if [ -n "$DRY_RUN" ]; then
    echo "=== DRY RUN MODE ==="
fi

if [ -n "$RESUME_MODE" ]; then
    echo "=== RESUME MODE ==="
    echo "Checking cache status before each scene..."
    echo ""
fi

# Clear log file at start of run (unless resuming - append instead)
mkdir -p "$(dirname "$LOG_FILE")"
if [ -n "$RESUME_MODE" ]; then
    echo "" >> "$LOG_FILE"
    echo "=== Resuming at $(date) ===" >> "$LOG_FILE"
else
    > "$LOG_FILE"
    echo "Log cleared: $LOG_FILE"
fi

# Error tracking
ERRORS=0
FAILED_SCENES=""
SUCCESSFUL=0
SKIPPED=0
TOTAL_SCENES={total_scenes}

echo "Analyzing {Play Name}..."
echo "Play file: $PLAY"
echo "Merge threshold: $MERGE lines"
echo "Log file: $LOG_FILE"
echo "Total scenes: $TOTAL_SCENES"
echo ""

# Opening Prologue (if exists)
{opening_prologue_section}

# Act sections (generated based on structure)
{act_sections}

# Epilogue (if exists)
{epilogue_section}

# Summary
echo ""
echo "=== ANALYSIS SUMMARY ==="
echo "Play: {Play Name}"
echo "Total scenes: $TOTAL_SCENES"
echo "Successful: $SUCCESSFUL"
if [ -n "$RESUME_MODE" ]; then
    echo "Skipped (cached): $SKIPPED"
fi
echo "Failed: $ERRORS"

if [ "$ERRORS" -gt 0 ]; then
    echo ""
    echo "[FAILED SCENES]"
    echo "$FAILED_SCENES"
    echo ""
    echo "[CLAUDE_ACTION_REQUIRED]"
    echo "$ERRORS scene(s) failed. Review errors above and in log file:"
    echo "  $LOG_FILE"
    echo ""
    echo "Suggested actions:"
    echo "1. Check log file for detailed error messages"
    echo "2. Run failed scenes individually to diagnose"
    echo "3. Use --resume to retry only failed/pending scenes"
    exit 1
else
    echo ""
    if [ -n "$RESUME_MODE" ] && [ "$SKIPPED" -gt 0 ]; then
        echo "Resume complete! $SKIPPED scenes were already cached."
    else
        echo "All scenes processed successfully!"
    fi
    echo "Output directory: ~/utono/literature/glosses/{play_name}/"
    exit 0
fi
```

### Analyzer call format (IMPORTANT)

The `scene_analyzer.py` takes **positional** act/scene arguments, NOT flags:

```bash
# CORRECT: positional arguments
python "$ANALYZER" "$PLAY" 4 7 --merge "$MERGE" $DRY_RUN

# WRONG: flag-style arguments (will fail)
python "$ANALYZER" "$PLAY" --act 4 --scene 7 --merge "$MERGE" $DRY_RUN
```

Generate each section call with error tracking and resume support like this:

```bash
# Opening Prologue (act 0, scene 0)
echo "--- Prologue (Opening) ---"
if [ -n "$RESUME_MODE" ] && python "$ANALYZER" "$PLAY" 0 0 --merge "$MERGE" --status 2>/dev/null; then
    echo "[SKIPPED] Prologue (Opening) - fully cached"
    ((SKIPPED++))
elif python "$ANALYZER" "$PLAY" 0 0 --merge "$MERGE" $DRY_RUN; then
    ((SUCCESSFUL++))
else
    ((ERRORS++))
    FAILED_SCENES="$FAILED_SCENES
  Prologue: exit code $?"
    echo "[FAILED] Prologue (Opening)"
fi

# Regular scene (Act 4, Scene 7)
echo "--- Act 4, Scene 7 ---"
if [ -n "$RESUME_MODE" ] && python "$ANALYZER" "$PLAY" 4 7 --merge "$MERGE" --status 2>/dev/null; then
    echo "[SKIPPED] Act 4, Scene 7 - fully cached"
    ((SKIPPED++))
elif python "$ANALYZER" "$PLAY" 4 7 --merge "$MERGE" $DRY_RUN; then
    ((SUCCESSFUL++))
else
    ((ERRORS++))
    FAILED_SCENES="$FAILED_SCENES
  Act 4 Scene 7: exit code $?"
    echo "[FAILED] Act 4, Scene 7"
fi

# Act prologue (Act 2, scene 0)
echo "--- Act 2, Prologue ---"
if [ -n "$RESUME_MODE" ] && python "$ANALYZER" "$PLAY" 2 0 --merge "$MERGE" --status 2>/dev/null; then
    echo "[SKIPPED] Act 2, Prologue - fully cached"
    ((SKIPPED++))
elif python "$ANALYZER" "$PLAY" 2 0 --merge "$MERGE" $DRY_RUN; then
    ((SUCCESSFUL++))
else
    ((ERRORS++))
    FAILED_SCENES="$FAILED_SCENES
  Act 2 Prologue: exit code $?"
    echo "[FAILED] Act 2, Prologue"
fi

# Epilogue - use "Epilogue" string argument
echo "--- Epilogue ---"
if [ -n "$RESUME_MODE" ] && python "$ANALYZER" "$PLAY" Epilogue --merge "$MERGE" --status 2>/dev/null; then
    echo "[SKIPPED] Epilogue - fully cached"
    ((SKIPPED++))
elif python "$ANALYZER" "$PLAY" Epilogue --merge "$MERGE" $DRY_RUN; then
    ((SUCCESSFUL++))
else
    ((ERRORS++))
    FAILED_SCENES="$FAILED_SCENES
  Epilogue: exit code $?"
    echo "[FAILED] Epilogue"
fi
```

### Status check format

For the `{status_checks}` section, generate status checks for each scene.
The `--status` flag returns exit code 0 if all cached, 1 if work pending:

```bash
# Status check for a scene (exit code 0 = cached, 1 = pending)
if python "$ANALYZER" "$PLAY" 4 7 --merge "$MERGE" --status 2>/dev/null; then
    ((CACHED++))
else
    ((PENDING++))
fi

# Status check for prologue
if python "$ANALYZER" "$PLAY" 0 0 --merge "$MERGE" --status 2>/dev/null; then
    ((CACHED++))
else
    ((PENDING++))
fi
```

Generate one status check per scene/prologue/epilogue in the play.

### Validate check format

For the `{validate_checks}` section, generate validation checks for each scene.
The `--validate` flag returns exit code 0 if scene exists, 1 if not found:

```bash
# Validate check for a scene (exit code 0 = found, 1 = not found)
if python "$ANALYZER" "$PLAY" 4 7 --validate 2>/dev/null; then
    ((VALID++))
else
    ((INVALID++))
    echo "  ✗ Act 4, Scene 7 - NOT FOUND"
fi

# Validate check for prologue
if python "$ANALYZER" "$PLAY" 0 0 --validate 2>/dev/null; then
    ((VALID++))
else
    ((INVALID++))
    echo "  ✗ Prologue (Opening) - NOT FOUND"
fi

# Validate check for epilogue
if python "$ANALYZER" "$PLAY" Epilogue --validate 2>/dev/null; then
    ((VALID++))
else
    ((INVALID++))
    echo "  ✗ Epilogue - NOT FOUND"
fi
```

Generate one validate check per scene/prologue/epilogue in the play.

### Step 5: Make each script executable

Run: `chmod +x ~/utono/nvim-glosses-qa/scripts/gloss-play_{play_name}.sh`

### Step 6: Report summary to user

Output a summary table showing:
- Each play processed
- Structure (acts, scenes, prologues)
- Total output files per play
- Path to generated script

## Example Output

For `/analyze-plays ~/utono/literature/shakespeare-william/gutenberg/*.txt`:

```
## Plays Analyzed: 3 files processed

| Play | Acts | Scenes | Prologues | Epilogue | Files | Script |
|------|------|--------|-----------|----------|-------|--------|
| Henry V | 5 | 23 | 6 | Yes | 28 | gloss-play_henry-v.sh |
| Hamlet | 5 | 20 | 0 | No | 20 | gloss-play_hamlet.sh |
| Macbeth | 5 | 28 | 0 | No | 28 | gloss-play_macbeth.sh |

**Total output files across all plays:** 76

## Generated Scripts

Scripts saved to: `~/utono/nvim-glosses-qa/scripts/`

### To run all (dry-run first recommended):

```bash
# Preview what will be processed
for script in ~/utono/nvim-glosses-qa/scripts/gloss-play_*.sh; do
    "$script" --dry-run
done

# Or run individually:
~/utono/nvim-glosses-qa/scripts/gloss-play_henry-v.sh --dry-run
~/utono/nvim-glosses-qa/scripts/gloss-play_hamlet.sh --dry-run
```
```

## Roman Numeral Conversion

For parsing:
- I=1, II=2, III=3, IV=4, V=5, VI=6, VII=7, VIII=8, IX=9, X=10
- FIRST=1, SECOND=2, THIRD=3, FOURTH=4, FIFTH=5

## Play File Locations

Shakespeare plays: `~/utono/literature/shakespeare-william/gutenberg/`

## Notes

- Scripts are saved in `~/utono/nvim-glosses-qa/scripts/`
- Merge threshold defaulted to 42 lines (can edit script to change)
- Log file: `~/utono/nvim-glosses-qa/logs/scene_analyzer.log` (cleared at start)
- `--status` flag shows cache status for all scenes (what's done vs pending)
- `--dry-run` flag previews without API calls
- `--resume` flag skips fully-cached scenes (efficient after interruption)
- `--validate` flag verifies all scenes exist before processing
- Caching means reruns skip already-analyzed speeches
- Safe to stop and restart - cached chunks are skipped automatically
- Use `--resume` after interruption for fastest restart
- Use `--validate` after script generation to catch errors early
- Wildcards expand at runtime, so `*.txt` matches all text files in directory
